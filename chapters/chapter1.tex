%-*-coding: utf-8-*-

\startrelatedwork
\chapter{Постановка задачи}
Язык KPHP уже существует более пяти лет.
За это время образовалась достаточно большая кодовая база.
Сейчас в проекте более 60000 строк кода и почти 30000 строк в файлах, содержащих тесты к нему, по результатам запуска \verb|sloccount| \cite{sloccount}.
Так как было решено, что необходимо добавить поддержку функций высших порядков и анонимных функций, важно было придумать лаконичное решение, вписывающиеся в текущую архитектуру.

В данной работе будет показано, как организовать логику передачи анонимных функций и сохранения их в переменные, вписывающуюся в имеющуюся архитектуру, учитывая, что KPHP -- это типизированный язык.
Продумать, как будут анонимные функции транслироваться в C++-код, и что они будут представлять из себя.
Каждый вызов анонимной функции необходимо транслировать в соответствующий код, вызывающий нужную функцию, который корректно обрабатывает все входные данные и захватывает нужное окружение.

Для передачи лямбда-функций, методов и других функций в качестве аргументов можно использовать мономорфизацию, которая отлично вписывается в текущую архитектуру.
В случае же записи в одно и тоже поле класса разных объектов лямбда-функций необходимо разработать интерфейсы.
Также надо продумать соответствующий синтаксис для возможности задания функционального типа в коде, и возможность сохранять в переменные различные лямбда-функции, которые можно вызывать без потери производительности.
При обработке синтаксиса для задания функционального типа, необходимо автоматически наследовать класс, представляющий лямбда-функцию, от интерфейса, автоматически сгенерированного при задании функционального типа. 

Для реализации интерфейсов были поставлены следующие цели:
\begin{enumerate}
  \item продумать, как поддержать ссылочную семантику;
  \item добавить возможность задания классов, которые реализуют тот или иной интерфейс;
  \item продумать архитектуру для создания наследования интерфейсов друг от друга;
  \item провести статический анализ на корректность классов, реализующих какие-либо интерфейсы;
  \item поддержать возможность проверки на подтип -- \verb|instanceof|;
  \item добавить в язык понижающие приведение;
  \item проанализировать состояние для различных переменных, выявить экземпляром какого из подтипов они являются, чтобы автоматически производить понижающее приведение, где это необходимо, что должно упростить использование интерфейсов разработчиками.
\end{enumerate}

Для уменьшения ошибок при написании анонимных функций с захватом внешних переменных необходимо разработать синтаксис, который будет ограничивать переменные на запись, добавляя им семантику константных переменных.
Зачастую разработчики не ожидают поведения, предоставляемого языком программирования PHP, когда они пытаются изменить захваченные переменные.
В спроектированной архитектуре для того, чтобы поменять значение захваченной переменной, необходимо будет скопировать ее в другую переменную, что не усложнит использование анонимных функций.

Для типизации встроенных в язык функций таких как \verb|array_map|, \verb|array_reduce| и другие следует продумать новый синтаксис.
Все они принимают функцию в качестве аргумента, типы аргументов которой зависят от передаваемых параметров во встроенную функцию.
Разработав систему задания типов для анонимных функций, необходимо понять, как внедрить это в существующую инфраструктуру языка KPHP для корректного сопоставления с типами во всех местах использования.

\section{Термины и понятия}
\textbf{Трансляция} -- перевод из одного языка программирования в другой с целью ускорения и уменьшения потребления памяти.

\textbf{Лямбда-функция} -- функция, которая не имеет уникального идентификатора и обычно создается в месте использования.

\textbf{Анонимная функция} -- лямбда-функция.

\textbf{Функция высших порядков} -- такая функция, которая либо принимает другую функцию в качестве аргумента, либо возвращает какую-либо функцию.

\textbf{Захваченная переменная} -- переменная, которая была сохранена каким-либо образом и продолжает существовать внутри лямбда-функции.

\textbf{Ссылочная семантика} -- семантика языка, при которой любое присвоение объектов в другие переменные копирует только ссылку на них.

\textbf{Понижающее приведение} -- преобразование переменной, ссылающийся на базовый класс, к одному из производных классов.

\textbf{Встроенная функция} -- функция, которая написана на C++, тело которой скрыто для разработчиков на языке KPHP, однако разработчики имеют возможность вызывать ее.

\textbf{Типизация} -- процесс сопоставления различных переменных с соответствующими типами, а также возвращаемых значений функций.

\textbf{Проверка на подтип} -- процесс, в результате которого получается значение из булева множества, истинность которого показывает является ли соответствующая переменная данным подтипом.

\textbf{Инстанс} -- один из экземпляров конкретного класса.

\textbf{Мономорфизация} -- техника, которая заключается в порождении мономорфного экземпляра для каждого случая использования полиморфной функции или типа.

\textbf{Примитивный тип} -- такой тип, встроенный в язык KPHP, который может представлять из себя один из типов: целое число, вещественное число, значение из булева множества, строка, а также массив.

\textbf{Тип-сумма} -- тип, построенный как дизъюнктное объедение исходных типов.

\textbf{Рантайм} -- среда выполнения или такое окружение, которое необходимо для выполнения программы. В KPHP -- это отдельная подключаемая библиотека.

\textbf{CFG} -- граф потока управления, множество всех возможных путей исполнения программы, представленное в виде графa.

\textbf{AST} -- абстрактное синтаксическое дерево, представляет из себя дерево, каждая вершина которого обозначает конструкцию, встречающуюся в исходном коде.

\textbf{JIT} -- технология увеличения производительности программных систем, вовлекающая компиляцию некоторых частей программы во время исполнения, а не до момента запуска.

\textbf{Манглирование} -- техника присвоения уникального имени различным объектам, встречающимся в программе.

\section{Актуальность}
\label{sec:actuality}
На текущий момент существует несколько способов решения поставленной задачи.
Один из вариантов -- отказ от использования KPHP в пользу других языков программирования.
Радикально менять язык программирования будет достаточно большой и трудоемкой задачей, которая вовлечет за собой денежные затраты со стороны компании и не оправдает свою стоимость.
В кодовой базе насчитывается почти два миллиона двести тысяч строк кода, написанных на языке KPHP (совместимым с PHP).
Если нанять в компанию 100 программистов, которые каждый рабочий день будут переписывать по 100 строчек кода, то у них уйдет на эту работу почти пять месяцев.
За это время появится новый код, а тем временем необходимо будет интегрировать в текущую архитектуру и исправить все допущенные ошибки -- на это тоже уйдет время.
Из-за трудоемкости и неоправданной стоимости данное решение не будет рассматриваться в дальнейшем.

Рассмотрим, что можно предпринять в данной ситуации. 
Так как код совместим с языком PHP, то разумным решением, на первый взгляд, будет запуск его с помощью интерпретатора.
Данный подход имеет право на существование, однако есть несколько недостатков:
\begin{enumerate}
  \item PHP не анализирует написанный код до момента запуска, что не позволяет находить ошибки, допущенные программистами на момент написания кода;
  \item в PHP нет возможности накладывать дополнительные ограничения на переменные и функции, которые существуют в KPHP и будут показаны далее;
  \item медленная скорость работы, из-за чего компания будет вынуждена увеличить количество дорогостоящих серверов, что в свою очередь влечет увеличение расходов.
\end{enumerate}

Следующим кандидатом может выступать язык Hack и его виртуальная машина HHVM, разработанные в компании Facebook.
Данный язык является диалектом PHP, который позволяет совмещать в себе динамическую и статическую типизацию.
У него есть некоторые недостатки, из-за которых его использование не подходит компании:
\begin{enumerate}
\item он не совместим с языком PHP, что вызывает некоторые сложности в его использовании: как минимум нужно будет исправить много кода, а также отказаться от возможности использовать стандартные средства для статического анализа, так как все они предназначены для PHP;

\item среда разработки PHPStorm не поддерживает Hack \cite{hack-postponed};

\item хоть у него и есть JIT \cite{hack-jit}, данный язык с его окружением по-прежнему на многих тестах медленнее KPHP, будет показано в главе \ref{sec:comparision}, что приведет нас к покупке дополнительных серверов и колоссальным затратам на их поддержку;

\item нужно переделать существующую инфраструктуру для развёртывания необходимого программного обеспечения на сервера, что займет много времени, в том числе возникнут дополнительные проблемы и спецэффекты, которые на данный момент сложно обнаружить.
\end{enumerate}

Из приведенных аргументов выше можно заключить, что переход на другие языки, даже очень близкие к KPHP трудоемкий на текущем этапе развития компании.
Рассмотрим примеры, в которых можно заменить использование лямбд и функций высших порядков в языке.
Пример, в котором отсутствует возможность сохранять анонимные функции в переменные:
\begin{lstlisting}[caption={Пример кода без анонимных функций},label={without_lambda}]
function debug_for_foo($x) {
  var_dump("in foo: value of x: {$x}");
}

function foo() {
  $x = get_new_x();
  debug_for_foo($x);

  $y = calc_value($x);
  debug_for_foo($y);
}
\end{lstlisting}

В листинге \ref{without_lambda} видно, что небольшой дублирующийся код требуется выделить, как внешнюю функцию вместо того, чтобы определить в локальной переменной, содержащую лямбда-функцию.
Также на этом примере наглядно продемонстрирована проблема того, что при вынесении небольших вспомогательных функций будет необходимо манглировать их имена специальным образом,  при условии, если их тело будет отличаться, что приведёт к загромождению кода и загрязнению глобального пространства имен функций.
С использованием лямбда-функций возможно переписать этот пример следующим образом, что несомненно улучшает читаемость кода и уменьшает затраченное время на его написание:
\begin{lstlisting}
function foo() {
  $debug = function($x) { var_dump("in foo: value of x: {$x}"); };
  $x = get_new_x();
  $debug($x);

  $y = calc_value($x);
  $debug($y);
}
\end{lstlisting}

Обойти проблему отсутствия функций высших порядков можно с помощью определения вспомогательных функций, которые будут вызывать необходимые функции:
\begin{lstlisting}[caption={Пример кода без функций высших порядков},label={without_getting_lambda}]
function debug_result_of_call($result) {
  var_dump("in function foo: value of x: {$x}");
}

function get_x_y_from_net() {
	return [get_x_from_server(), get_y_from_server()];
}

function get_sum($x, $y) {
    return $x + $y;
}

function debug_result_of_call_sum() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sum($x, $y));
}

function get_sub($x, $y) {
    return $x - $y;
}

function debug_result_of_call_sub() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sub($x, $y));
}

function debug_combinations_of_x_y() {
	debug_result_of_call_sum();
	debug_result_of_call_sub();
}
\end{lstlisting}

В листинге \ref{without_getting_lambda} отображены явные недостатки отсутствия функций высших порядков.
Так как необходимо избавляться от дублирования кода, программисты будут все общие части выносить в отдельные функции.
На этом примере также показана необходимость создания временных имен для того, чтобы вызывать разные функции, и чем больше будет таких примеров, тем больше будет ненужных функций в коде, которые ухудшают читаемость и подвергаются ошибкам, допускаемыми при копировании схожих частей кода.
Ниже приведено решение данной проблемы, в котором используются функции высших порядков:
\begin{lstlisting}
function debug_result(callable $get_result) {
	list(x, y) = [get_x_from_server(), get_y_from_server()];
	var_dump("in function foo: value of x: ".$get_result($x));
}

function debug_combinations_of_x_y() {
	debug_result(function ($x, $y) { return $x + $y; });
	debug_result(function ($x, $y) { return $x - $y; });
}
\end{lstlisting}

Простота и изящность -- так можно охарактеризовать, приведенный код выше.
Данный листинг показывает, что писать на языке без лямбда-функций и функций высших порядков довольно-таки сложно, а допустить ошибку в коде становится легче.
В текущий момент возникают следующие сложности.
На данном этапе в языке нет синтаксиса, для спецификации типов аргументов лямбда функций и типа возвращаемого значения, поэтому считается, что все они возвращают некоторый тип-суммы примитивных типов.
Это в свою очередь приводит к тому, что мы не можем их использовать с экземплярами классов, например:
\begin{lstlisting}
class MyClass { public $x = 10; }

$arr = [new MyClass(), new MyClass];
$xs = array_map(function($m) { return $m->x; }, $arr);
\end{lstlisting}

Этот пример показывает отсутствие возможности написать такой код, так как принимаемое значение должно иметь примитивный тип, и попытка передать ему экземпляр класса заканчивается неудачей.
Соответственно нельзя использовать встроенные функции с экземплярами классов.
Также использование встроенных функций с лямбда-функциями там, где передаются параметры с конкретными типами, ухудшит производительность из-за обобщения примитивных типов до типа-суммы.
Например, если передать массив чисел и лямбда-функцию, которая возвращает число во встроенную функцию \verb|array_map|, то в текущей реализации будет получен массив \verb|var| -- тип, который может хранить значения любого примитивного типа.
\finishrelatedwork

\section{Уточненные требования к работе}
В предыдущей секции были рассмотрены примеры и показана необходимость создания поддержки лямбда-функций и функций высших порядков в языке KPHP.
Далее будут показаны детализированные этапы, необходимые для совершения данной работы.

Сначала нужно разобраться, что из себя представляют анонимные функции, то есть прочитать соответствующую спецификацию к языку PHP, выделить основные моменты и тонкости синтаксиса.
Необходимо реализовать синтаксический анализ таких функций с дальнейшим построением AST, введя соответствующие типы вершин дерева.
Решить, во что будет транслироваться создание анонимных функций, и как будет реализован вызов.
Также необходимо поддержать ссылочную семантику при создании лямбда-функций.
Продумать, куда сохранять захваченные переменные в теле лямбда-функции.
Необходимо модифицировать тело анонимной функции таким образом, чтобы все обращения к захваченным переменным происходили через экземпляр только что созданного класса.
Нужно учитывать, что при определении анонимных функций внутри метода класса, требуется неявно захватывать \verb|$this|, а также позаботиться о том, чтобы все обращения в теле лямбда-функции, например, \verb|$this->field_name|, были корректно обработаны.

Следующим этапом будет продумывание семантики для захваченных переменных, как говорилось ранее, нужно разработать синтаксис, который бы ограничивал захваченные переменные на запись.
Следовательно, стоит ввести аннотацию \verb|@kphp-const| и соответствующие модификаторы во внутренних структурах, позволяющие проверять переменные на изменения.
Также необходимо спроектировать инфраструктуру для проверки кода, и выдачи ошибок пользователям о произошедшей модификации переменной, которая помечена данной аннотацией.

Для создания функций высших порядков надо продумать, каким образом будет происходить передача лямбда-функций.
Транслирование будет происходить в типизированный язык, а семантика PHP запрещает перегрузку функций.
В следствии этого необходимо произвести соответствующую мономорфизацию функций, принимающих другие функции.
В связи с этим, надо разработать специальный синтаксис для поддержки шаблонных функций в языке KPHP, которыми смогут пользоваться другие разработчики, и по возможности компилятор должен автоматически понимать, какие параметры можно аннотировать шаблонными типами автоматически.

Для того, чтобы создать корректную типизацию встроенных функций, в которые передают другие функции, необходимо будет:
\begin{enumerate}
  \item разработать новый синтаксис для аннотирования;
  \item аннотировать разработанным синтаксисом все существующие стандартные функции;
  \item поддержать синтаксический анализ аннотаций и сохранить нужную метаинформацию в вершинах AST;
  \item корректно вывести типы у всех аргументов встроенной функции, учитывая то, что они аннотированы соответствующими зависимыми типами;
  \item определить типы параметров анонимных функций, передаваемых во встроенные функции;
  \item провести корректную трансляцию вызовов встроенных функций, в которые передают лямбда-функции.
\end{enumerate}

Для того, чтобы появилась возможность сохранять различные лямбда-функции, имеющие схожую сигнатуру, в одну и ту же переменную, надо разработать поддержку интерфейсов в языке KPHP.
Для чего необходимо: изучить текущую спецификацию и возможные подводные камни, разобрать синтаксис, научиться транслировать интерфейсы.
Также внедрить генерацию виртуальных методов интерфейсов и проверку на нужный подтип.

\chapterconclusion
В данной главе была детально рассмотрена поставленная задача.
Разобрана ее актуальность и необходимость реализации.
Приведены примеры, в каких ситуациях без поддержки данной функциональности не получится должного дальнейшего развития языка.
Проведено сравнение с другими решениями, из чего можно заключить, что принятое решение о разработке данной задачи, именно в языке KPHP оправдано.

Также были рассмотрены этапы, необходимые для построения архитектуры и дальнейшего анализа, отражающие сложность и многогранность поставленной задачи.
В следующих главах будет подробнее рассказано о каждом этапе и будут рассмотрены приемлемые варианты для их решения.
Также будет показано сравнение разработанного решения с аналогами, показана оправданность и справедливость данных подходов.
