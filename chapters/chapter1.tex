%-*-coding: utf-8-*-

\chapter{Постановка задачи}
Язык \verb|KPHP| уже существует более пяти лет за это время образовалась достаточно большая кодовая база.
Сейчас в проекте более 60000 строк кода и почти 30000 строк в файлах содержащих тесты к проекты, по результатам запуска \verb|sloccount|\cite{sloccount}. Так как мы решили, что должны добавить поддержку функций высших порядков и анонимных функций важно было придумать лаконичное решение, вписывающиеся в текущую архитектуру.

В данной работе нам предстоит придумать, как организовать логику передачи анонимных функций и сохранения их в переменные. \verb|KPHP| - типизированный язык для данной задачи необходимо придумать соответствующую логику, вписывающуюся в имеющуюся архитектуру. Продумать как будут анонимные функции транслироваться в \verb|C++| код и что они будут представлять из себя. Каждый вызов анонимной функции транслировать в соответствующий код вызывающий нужную функцию, который корректно обрабатывает все входные данные и захватит нужное окружение.

Для передачи лямбд, методов и других функций в качестве аргументов можно использовать мономорфизацию, которая отлично вписывается в текущую архитектуру, но вот для записи в одно и тоже поле класса разных инстансов лямбда функций будет сложнее. Для этого необходимо разработать интерфейсы и соответствующий синтаксис для возможности задания функционального типа в коде и сохранение в него различных объектов, которые можно вызывать без потери производительности, которые в свою очередь будут автоматически наследоваться от соответствующего интерфейса. 

Нужно продумать как поддержать ссылочную семантику для интерфейсов. Добавить возможность задания классов, которые реализуют тот или иной интерфейс, продумать дизайн для создания наследования интерфейсов друг от друга. Сделать статический анализ на корректность унаследовавшихся классов. Поддержать возможность проверки на подтип \verb|instanceof| и сделать возможным понижающие приведение. Также нужно научиться поддерживать состояние для различных переменных, экземпляром какого из подтипа она может являться, чтобы автоматически производить понижающее приведение где это необходимо - это должно значительно упростить использование интерфейсов разработчиками.

Для уменьшения ошибок при написании анонимных функций с захватом внешних переменных разработать синтаксис, который будет ограничивать переменные на запись, добавляя им семантику константных переменных. Зачастую разработчики не ожидают поведения, предоставляемого языков \verb|PHP|, когда они пытаются изменить захваченные переменные, а если им нужно будет поменять, то нужно будет всего лишь скопировать в другую переменную, чтобы наверняка понимать, что захваченные аргументы не меняют своих значений.

Нужно продумать новый синтаксис для типизации встроенных в язык функций таких как \verb|array_map|, \verb|array_reduce| и другие. Все они принимают анонимную функцию в качестве аргумента, типы аргументов которой зависят от передаваемых параметров встроенной функции. Разработав систему задания типов для анонимных функций, нужно понять как внедрить это в язык \verb|KPHP|, для корректного сопоставления с типами во всех местах использования.

\section{Термины и понятия}
\textbf{Трансляция} -- перевод из одного языка программирования в другой с целью ускорения и уменьшения потребления памяти.

\textbf{Лямбда функция}-- функция, которая не имеет уникального идентификатора и обычно создаются в месте использования.

\textbf{Анонимная функция} -- лямбда функция.

\textbf{Функция высших порядков} -- либо принимает другую функцию как аргумент, либо возвращает созданную в теле функцию.

\textbf{Захваченная переменная} -- переменная которая была сохранена и продолжает существовать внутри лямбда функции.

\textbf{Ссылочная семантика} -- когда любое присвоение объектов в другие переменные копирует только ссылку на него.

\textbf{Понижающее приведение} -- преобразование переменной, ссылающийся на базовый класс, к одному из производных классов.

\textbf{Встроенные функции} -- функции которые написаны на \verb|C++|, тело которых скрыто для разработчиков на языке \verb|KPHP|, однако они имеют возможность вызывать их.

\textbf{Типизация} -- процесс сопоставления различных переменных с соответствующими типами, а также возвращаемых значений функций.

\textbf{Проверка на подтип} -- процесс в результате которого получается булевское значение истинность которого показывает является ли соответствующая переменная данным подтипом.

\textbf{Инстанс} -- один из экземпляров конкретного класса.

\textbf{Мономорфизация} -- техника, которая заключается в порождении мономорфного экземпляра для каждого случая использования полиморфной функции или типа.

\textbf{Примитивный тип} -- такой тип, встроенный в язык \verb|KPHP|, который может представлять из себя один из типов: целых чисел, вещественных чисел, значений из булева множества, строк, а также массивов.

\textbf{Тип-сумма} -- тип построенный как дизъюнктное объедение исходных типов.

\section{Актуальность}
На текущий момент существует несколько способов решения поставленной задачи. Один из простых вариант, который можно рассмотреть -- это отказ от использования \verb|KPHP| в пользу других языков программирования. 
Радикально менять язык программирования будет достаточно большой и трудоемкой задачей, которая вовлечет за собой огромные денежные затраты со стороны компании и вряд ли оправдает свою стоимость. 
В кодовой базе насчитывается более двух миллионов строк кода, написанных на языке \verb|KPHP| (совместимым с \verb|PHP|).
Даже если нанять 100 программистов, которые каждый рабочий день будут переписывать по 100 строчек кода, то у них уйдет на это почти пять месяцев. За это время конечно же появится новый код, а еще нужно будет интегрировать в текущую архитектуру и исправить все допущенные ошибки - на это тоже уйдет достаточно много времени.
Из-за трудоемкости и неоправданной дороговизне мы не будем рассматривать данное решение в дальнейшем.

Посмотрим, что еще мы можем предпринять в данной ситуации. 
Так как код написан на \verb|PHP|, то кажется разумным решением его и запускать с помощью интерпретатора. 
Этот подход имеет право на существование, но как мы увидим в следующих главах он также имеет множество недостатков.
Например \verb|KPHP| анализирует написанный код, что позволяет находить массу ошибок, допущенных программистами.
Также в \verb|KPHP| существует дополнительные возможности, совместимые с языком \verb|PHP|, для применения дополнительных ограничений на переменные и проверка их до момента запуска.
Основным преимуществом конечно же является скорость работы, которая позволяет уменьшить количество дорогостоящих серверов, что в свою очередь влечет снижение расходов компании на содержание и закупку новых.

Следующим кандидатом может выступать язык \verb|HACK| и его виртуальная машина \verb|HHVM|, разработанные в компании facebook.
Данный язык является диалектом \verb|PHP|, который позволяет совмещать в себе динамическую и статическую типизацию.
У него есть несколько недостатков, из-за которых его использование не подходит компании:

\begin{enumerate}
\item Он не совместим с языком \verb|PHP|, что вызывает некоторые сложности в его использовании, как минимум нужно будет исправить много кода, а также мы лишимся возможности использовать стандартные средства для статического анализа, так как все они предназначены для \verb|PHP|;

\item Хоть у него и есть \verb|JIT|, данный язык с его окружением по прежнему на многих тестах медленнее \verb|KPHP|, что будет показано далее, что приведет нас к покупке дополнительных серверов и колоссальным затратам на их поддержку;

\item Нужно переделать существующую инфраструктура для деплоя его на сервера, что тоже займет не мало времени, в том числе возникнут дополнительные проблемы и спецэффекты о которых мы сейчас даже не можем предположить.
\end{enumerate}

Из приведенных аргументов выше мы понимаем, что переход на другие языки, даже очень близкие к \verb|KPHP| невозможен на текущем этапе развития компании, то давайте взглянем на несколько примеров, которые могут заменить использование лямбд и функций высших порядков в языке.
Посмотрим, что происходит, если у нас отсутствует возможность сохранять анонимные функции в переменные:
\begin{lstlisting}[caption={Пример кода без анонимных функций},label={without_lambda}]
function debug_for_foo($x) {
  var_dump("in foo: value of x: {$x}");
}

function foo() {
  $x = get_new_x();
  debug_for_foo($x);

  $y = calc_value($x);
  debug_for_foo($y);
}
\end{lstlisting}

В листинге \ref{without_lambda} видно, что небольшой дублирующийся код мы вместо того, чтобы вынести локально в переменную, содержащую анонимную функцию, и тут же его вызывать, вынуждены определять в отдельной функции.
Также на этом примере наглядно продемонстрирована проблема того, что при вынесении всех таких мелких вспомогательных функций мы будем вынуждены манглировать их имена специальным образом, если их тело будет отличаться в разных функциях, что приводят к загромождению кода и загрязнению глобального пространства имен функций.
С использованием лямбд мы могли бы переписать его следующим образом, что несомненно улучшает читаемость кода и уменьшает затраченное время на написание его:
\begin{lstlisting}
function foo() {
  $debug = function($x) { var_dump("in foo: value of x: {$x}"); };
  $x = get_new_x();
  $debug($x);

  $y = calc_value($x);
  $debug($y);
}
\end{lstlisting}

Теперь посмотрим, как можно обойти проблему отсутствия функций высших порядков, с помощью определения нескольких функций, которые будут вызывать другие функции:
\begin{lstlisting}[caption={Пример кода без функций высших порядков},label={without_getting_lambda}]
function debug_result_of_call($result) {
  var_dump("in function foo: value of x: {$x}");
}

function get_x_y_from_net() {
	return [get_x_from_server(), get_y_from_server()];
}

function get_sum($x, $y) {
    return $x + $y;
}

function debug_result_of_call_sum() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sum($x, $y));
}

function get_sub($x, $y) {
    return $x - $y;
}

function debug_result_of_call_sub() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sub($x, $y));
}

function debug_combinations_of_x_y() {
	debug_result_of_call_sum();
	debug_result_of_call_sub();
}
\end{lstlisting}

В листинге \ref{without_getting_lambda} отображены явные недостатки отсутствия функций высших порядков.
Так как мы хотим максимально избавиться от дублирования кода, мы вынуждены все общие части выносить в отдельные функции.
На этом примере также показана необходимость создания временных имен, для того, чтобы вызывать разные функции и чем больше будет таких примеров, тем сильнее разрастется код ненужными сущностями, которые ухудшают читаемость и склоны к ошибкам, допускаемыми при копировании похожих частей кода.
Давайте взглянем как надо было бы решать данную проблему используя функции высших порядков:
\begin{lstlisting}
function debug_result(callable $get_result) {
	list(x, y) = [get_x_from_server(), get_y_from_server()];
	var_dump("in function foo: value of x: ".$get_result($x));
}

function debug_combinations_of_x_y() {
	debug_result(function ($x, $y) { return $x + $y; });
	debug_result(function ($x, $y) { return $x - $y; });
}
\end{lstlisting}

Простота и изящность - так можно охарактеризовать, приведенный код выше.
Данный листинг показывает, что писать на языке без лямбд и функций высших порядков довольно таки сложно, а допустить ошибку в коде становится намного легче.
Давайте взглянем какие еще сложности у нас возникают в текущей момент.
На данном этапе у нас нет синтаксиса, для спецификации типов аргументов лямбда функций и типа возвращаемого значения, поэтому, считается, что все они возвращают некоторый тип-суммы примитивных типов.
Что в свою очередь приводит к тому, что мы не можем их использовать с экземплярами классов, например:
\begin{lstlisting}
class MyClass { public $x = 10; }

$arr = [new MyClass(), new MyClass];
$xs = array_map(function($m) { return $m->x; }, $arr);
\end{lstlisting}

Этот пример отображает невозможность написать такой код, так как принимаемое значение должно иметь примитивный тип, а мы пытаемся передать ему экземпляр класса.
Соответственно все встроенные функции будут запрещены в использовании с классами.
Также использования встроенных функций с лямбдами там, где тип выводится верно, например с массивом чисел мы получим ухудшения в производительности, из-за обобщения примитивных типов до типа-суммы.


\section{Уточненные требования к работе}
Рюзимируем коротко требования.

\chapterconclusion
Из этой главы мы поняли, что задача достаточно трудоемкая и требует глубокого анализа поставленной задачи.
Рассмотрим недостатки существующих решений в следующих главах.

