%-*-coding: utf-8-*-

\chapter{Постановка задачи}
Язык KPHP уже существует более пяти лет за это время образовалась достаточно большая кодовая база.
Сейчас в проекте более 60000 строк кода и почти 30000 строк в файлах содержащих тесты к проекты, по результатам запуска \verb|sloccount|\cite{sloccount}. Так как мы решили, что должны добавить поддержку функций высших порядков и анонимных функций важно было придумать лаконичное решение, вписывающиеся в текущую архитектуру.

В данной работе нам предстоит придумать, как организовать логику передачи анонимных функций и сохранения их в переменные. KPHP - типизированный язык для данной задачи необходимо придумать соответствующую логику, вписывающуюся в имеющуюся архитектуру. Продумать как будут анонимные функции транслироваться в C++ код и что они будут представлять из себя. Каждый вызов анонимной функции транслировать в соответствующий код вызывающий нужную функцию, который корректно обрабатывает все входные данные и захватит нужное окружение.

Для передачи лямбд, методов и других функций в качестве аргументов можно использовать мономорфизацию, которая отлично вписывается в текущую архитектуру, но вот для записи в одно и тоже поле класса разных инстансов лямбда функций будет сложнее. Для этого необходимо разработать интерфейсы и соответствующий синтаксис для возможности задания функционального типа в коде и сохранение в него различных объектов, которые можно вызывать без потери производительности, которые в свою очередь будут автоматически наследоваться от соответствующего интерфейса. 

Нужно продумать как поддержать ссылочную семантику для интерфейсов. Добавить возможность задания классов, которые реализуют тот или иной интерфейс, продумать дизайн для создания наследования интерфейсов друг от друга. Сделать статический анализ на корректность унаследовавшихся классов. Поддержать возможность проверки на подтип \verb|instanceof| и сделать возможным понижающие приведение. Также нужно научиться поддерживать состояние для различных переменных, экземпляром какого из подтипа она может являться, чтобы автоматически производить понижающее приведение где это необходимо - это должно значительно упростить использование интерфейсов разработчиками.

Для уменьшения ошибок при написании анонимных функций с захватом внешних переменных разработать синтаксис, который будет ограничивать переменные на запись, добавляя им семантику константных переменных. Зачастую разработчики не ожидают поведения, предоставляемого языков PHP, когда они пытаются изменить захваченные переменные, а если им нужно будет поменять, то нужно будет всего лишь скопировать в другую переменную, чтобы наверняка понимать, что захваченные аргументы не меняют своих значений.

Нужно продумать новый синтаксис для типизации встроенных в язык функций таких как \verb|array_map|, \verb|array_reduce| и другие. Все они принимают анонимную функцию в качестве аргумента, типы аргументов которой зависят от передаваемых параметров встроенной функции. Разработав систему задания типов для анонимных функций, нужно понять как внедрить это в язык KPHP, для корректного сопоставления с типами во всех местах использования.

\section{Термины и понятия}
\textbf{Трансляция} -- перевод из одного языка программирования в другой с целью ускорения и уменьшения потребления памяти.

\textbf{Лямбда функция} -- функция, которая не имеет уникального идентификатора и обычно создаются в месте использования.

\textbf{Анонимная функция} -- лямбда функция.

\textbf{Функция высших порядков} -- либо принимает другую функцию как аргумент, либо возвращает созданную в теле функцию.

\textbf{Захваченная переменная} -- переменная которая была сохранена и продолжает существовать внутри лямбда функции.

\textbf{Ссылочная семантика} -- когда любое присвоение объектов в другие переменные копирует только ссылку на него.

\textbf{Понижающее приведение} -- преобразование переменной, ссылающийся на базовый класс, к одному из производных классов.

\textbf{Встроенные функции} -- функции которые написаны на C++, тело которых скрыто для разработчиков на языке KPHP, однако они имеют возможность вызывать их.

\textbf{Типизация} -- процесс сопоставления различных переменных с соответствующими типами, а также возвращаемых значений функций.

\textbf{Проверка на подтип} -- процесс в результате которого получается булевское значение истинность которого показывает является ли соответствующая переменная данным подтипом.

\textbf{Инстанс} -- один из экземпляров конкретного класса.

\textbf{Мономорфизация} -- техника, которая заключается в порождении мономорфного экземпляра для каждого случая использования полиморфной функции или типа.

\textbf{Примитивный тип} -- такой тип, встроенный в язык KPHP, который может представлять из себя один из типов: целых чисел, вещественных чисел, значений из булева множества, строк, а также массивов.

\textbf{Тип-сумма} -- тип построенный как дизъюнктное объедение исходных типов.

\textbf{Рантайм} -- среда выполнения или такое окружение, которое необходимо для выполнения программы. В KPHP - это отдельная подключаемая библиотека.

\textbf{CFG} -- граф потока управления, множество всех возможных путей исполнения программы, представленное в виде графa.

\textbf{AST} -- абстрактное синтаксическое дерево, представляет из себя дерево, каждая вершина которого обозначает конструкцию, встречающуюся в исходном коде.

\section{Актуальность}
На текущий момент существует несколько способов решения поставленной задачи. Один из простых вариант, который можно рассмотреть -- это отказ от использования KPHP в пользу других языков программирования. 
Радикально менять язык программирования будет достаточно большой и трудоемкой задачей, которая вовлечет за собой огромные денежные затраты со стороны компании и вряд ли оправдает свою стоимость. 
В кодовой базе насчитывается более двух миллионов строк кода, написанных на языке KPHP (совместимым с PHP).
Даже если нанять 100 программистов, которые каждый рабочий день будут переписывать по 100 строчек кода, то у них уйдет на это почти пять месяцев. За это время конечно же появится новый код, а еще нужно будет интегрировать в текущую архитектуру и исправить все допущенные ошибки - на это тоже уйдет достаточно много времени.
Из-за трудоемкости и неоправданной дороговизне мы не будем рассматривать данное решение в дальнейшем.

Посмотрим, что еще мы можем предпринять в данной ситуации. 
Так как код написан на PHP, то кажется разумным решением его и запускать с помощью интерпретатора. 
Этот подход имеет право на существование, но как мы увидим в следующих главах он также имеет множество недостатков.
Например KPHP анализирует написанный код, что позволяет находить массу ошибок, допущенных программистами.
Также в KPHP существует дополнительные возможности, совместимые с языком PHP, для применения дополнительных ограничений на переменные и проверка их до момента запуска.
Основным преимуществом конечно же является скорость работы, которая позволяет уменьшить количество дорогостоящих серверов, что в свою очередь влечет снижение расходов компании на содержание и закупку новых.

Следующим кандидатом может выступать язык Hack и его виртуальная машина HHVM, разработанные в компании facebook.
Данный язык является диалектом PHP, который позволяет совмещать в себе динамическую и статическую типизацию.
У него есть несколько недостатков, из-за которых его использование не подходит компании:

\begin{enumerate}
\item Он не совместим с языком PHP, что вызывает некоторые сложности в его использовании, как минимум нужно будет исправить много кода, а также мы лишимся возможности использовать стандартные средства для статического анализа, так как все они предназначены для PHP;

\item Хоть у него и есть JIT, данный язык с его окружением по прежнему на многих тестах медленнее KPHP, что будет показано далее, что приведет нас к покупке дополнительных серверов и колоссальным затратам на их поддержку;

\item Нужно переделать существующую инфраструктура для деплоя его на сервера, что тоже займет не мало времени, в том числе возникнут дополнительные проблемы и спецэффекты о которых мы сейчас даже не можем предположить.
\end{enumerate}

Из приведенных аргументов выше мы понимаем, что переход на другие языки, даже очень близкие к KPHP невозможен на текущем этапе развития компании, то давайте взглянем на несколько примеров, которые могут заменить использование лямбд и функций высших порядков в языке.
Посмотрим, что происходит, если у нас отсутствует возможность сохранять анонимные функции в переменные:
\begin{lstlisting}[caption={Пример кода без анонимных функций},label={without_lambda}]
function debug_for_foo($x) {
  var_dump("in foo: value of x: {$x}");
}

function foo() {
  $x = get_new_x();
  debug_for_foo($x);

  $y = calc_value($x);
  debug_for_foo($y);
}
\end{lstlisting}

В листинге \ref{without_lambda} видно, что небольшой дублирующийся код мы вместо того, чтобы вынести локально в переменную, содержащую анонимную функцию, и тут же его вызывать, вынуждены определять в отдельной функции.
Также на этом примере наглядно продемонстрирована проблема того, что при вынесении всех таких мелких вспомогательных функций мы будем вынуждены манглировать их имена специальным образом, если их тело будет отличаться в разных функциях, что приводят к загромождению кода и загрязнению глобального пространства имен функций.
С использованием лямбд мы могли бы переписать его следующим образом, что несомненно улучшает читаемость кода и уменьшает затраченное время на написание его:
\begin{lstlisting}
function foo() {
  $debug = function($x) { var_dump("in foo: value of x: {$x}"); };
  $x = get_new_x();
  $debug($x);

  $y = calc_value($x);
  $debug($y);
}
\end{lstlisting}

Теперь посмотрим, как можно обойти проблему отсутствия функций высших порядков, с помощью определения нескольких функций, которые будут вызывать другие функции:
\begin{lstlisting}[caption={Пример кода без функций высших порядков},label={without_getting_lambda}]
function debug_result_of_call($result) {
  var_dump("in function foo: value of x: {$x}");
}

function get_x_y_from_net() {
	return [get_x_from_server(), get_y_from_server()];
}

function get_sum($x, $y) {
    return $x + $y;
}

function debug_result_of_call_sum() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sum($x, $y));
}

function get_sub($x, $y) {
    return $x - $y;
}

function debug_result_of_call_sub() {
	list($x, $y) = get_x_y_from_net();
	debug_result_of_call(get_sub($x, $y));
}

function debug_combinations_of_x_y() {
	debug_result_of_call_sum();
	debug_result_of_call_sub();
}
\end{lstlisting}

В листинге \ref{without_getting_lambda} отображены явные недостатки отсутствия функций высших порядков.
Так как мы хотим максимально избавиться от дублирования кода, мы вынуждены все общие части выносить в отдельные функции.
На этом примере также показана необходимость создания временных имен, для того, чтобы вызывать разные функции и чем больше будет таких примеров, тем сильнее разрастется код ненужными сущностями, которые ухудшают читаемость и склоны к ошибкам, допускаемыми при копировании похожих частей кода.
Давайте взглянем как надо было бы решать данную проблему используя функции высших порядков:
\begin{lstlisting}
function debug_result(callable $get_result) {
	list(x, y) = [get_x_from_server(), get_y_from_server()];
	var_dump("in function foo: value of x: ".$get_result($x));
}

function debug_combinations_of_x_y() {
	debug_result(function ($x, $y) { return $x + $y; });
	debug_result(function ($x, $y) { return $x - $y; });
}
\end{lstlisting}

Простота и изящность - так можно охарактеризовать, приведенный код выше.
Данный листинг показывает, что писать на языке без лямбд и функций высших порядков довольно таки сложно, а допустить ошибку в коде становится намного легче.
Давайте взглянем какие еще сложности у нас возникают в текущей момент.
На данном этапе у нас нет синтаксиса, для спецификации типов аргументов лямбда функций и типа возвращаемого значения, поэтому, считается, что все они возвращают некоторый тип-суммы примитивных типов.
Что в свою очередь приводит к тому, что мы не можем их использовать с экземплярами классов, например:
\begin{lstlisting}
class MyClass { public $x = 10; }

$arr = [new MyClass(), new MyClass];
$xs = array_map(function($m) { return $m->x; }, $arr);
\end{lstlisting}

Этот пример отображает невозможность написать такой код, так как принимаемое значение должно иметь примитивный тип, а мы пытаемся передать ему экземпляр класса.
Соответственно все встроенные функции будут запрещены в использовании с классами.
Также использования встроенных функций с лямбдами там, где тип выводится верно, например с массивом чисел мы получим ухудшения в производительности, из-за обобщения примитивных типов до типа-суммы.


\section{Уточненные требования к работе}
В предыдущей секции мы рассмотрели примеры и убедились в необходимости создания поддержки лямбд и анонимных функций в языке KPHP. Давайте попробуем детализировать этапы, необходимые для совершения данной работы и что нам предстоит реализовать.

Сначала нужно разобраться, а что из себя представляют анонимные функции, прочитать соответствующую спецификацию к языку PHP и выделить основные моменты и детали синтаксиса.
Мы должны будем написать разбор таких функций с дальнейшим построением AST, введя необходимые типы вершин для этого.
Надо решить во что мы будем транслировать создание анонимных функций и как будет происходить вызов, надо не забыть поддержать ссылочную семантику при создании лямбд.
Также стоит определить куда сохранять захваченные переменные в тело лямбды, а после необходим модифициворать ее тело таким образом, чтобы все обращения к захваченным переменным происходили через экземпляр класса лямбды.
Нужно учитывать, что при определении лямбды внутри метода класса, нужно неявно захватывать \verb|$this|, а также позаботиться о том, что все обращения внутри \verb|$this->field_name| были корректно обработаны.

Следующим этапом будет продумывание семантики для захваченных переменных, как говорилось ранее нужно придумать синтаксис, который бы ограничивал, захваченные переменные на запись.
Соответственно стоит ввести аннотацию \verb|@kphp-const| и соответствующие модификаторы во внутренних структурах, позволяющие проверять на изменения данных переменных.
Также соответственно надо разработать инфраструктуру для проверки кода, и выдачи ошибок пользователям о произошедшей модификации переменной, которая помечена данной аннотацией.

Для создания функций высших порядков, необходимо придумать каким образом мы будем передавать туда лямбда функции, так как мы транслируем в типизированный язык, а семантика PHP запрещает перегрузку функций, то необходимо произвести соответствующую мономорфизацию функций принимающих другие функции.
Соответственно необходимо разработать специальный синтаксис для поддержки шаблонных функций в языке KPHP, которыми смогут пользоваться другие разработчики и по возможности автоматически понимать в каких местах можно аннотировать параметры как шаблонные за них.

Надо разработать новый синтаксис для типизации передаваемых анонимных функций во встроенные функции.
Аннотировать разработанным синтаксисом все существующие стандартные функции.
Поддержать их парсинг и сохранение нужной мета-информации в вершинах AST дерева.
Внедрить вывод типов для случаев передачи лямбд в стандартные функции.
Поддержать корректную трансляцию таких вызовов, а также рассмотреть как выводить результирующие типы корректно во всех возможных случаях использования.

Для того чтобы появилась возможность сохранять различные лямбда функции, но имеющие схожую сигнатуру в одну и ту же переменную, надо разработать поддержку интерфейсов в языке.
Для чего необходимо изучить текущую спецификацию их и возможные подводные камни.
Разобрать синтаксис, научиться транслировать их.
Также необходимо разработать генерацию виртуальных методов интерфейсов и проверку на подтип.

\chapterconclusion
В данной главе мы детально познакомились с поставленной задачей.
Разобрали ее актуальность и необходимость реализации.
Привели примеры в каких ситуациях без поддержки данной функциональности у нас не получится должного дальнейшего развития языка.
Сравнили с другими решениями из чего заключили, что принятое решение о разработке именно в языке KPHP данной задачи оправдано.

Также были рассмотрены этапы, необходимые для построения архитектуры и дальнейшего анализа, отражающие сложность и многогранность поставленной перед нами задачи.
В следующих главах остановимся подробнее на каждом этапе и посмотрим какие варианты были бы приемлемы для решения и почему мы остановились именно на таком варианте.
Также будет показано сравнение разработанного решения с аналогами и увидим оправданность справедливость данных подходов.
