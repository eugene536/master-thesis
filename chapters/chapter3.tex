%-*-coding: utf-8-*-

\chapter{Сравнение с другими решениями}
В данной главе будут рассмотрены спроектированные и реализованные решения для поддержки лямбда-функций и функций высших порядков.
Посмотрим как влияют на производительность и память одинаковые конструкции в языках Hack, PHP и KPHP.
Посмотрим какие ошибки стали обнаруживаться при добавление анонимных функций.

\section{Потребление CPU для различных решений}
Давайте рассмотрим время затраченное на различные конструкции.
Начнем с того, сколько времени у нас занимает простое создание лямбда-функций.
Тест представленный в листинге \ref{lst:benchmark-create-simple}, будет в цикле много раз создавать обычную лямбда-функцию, KPHP - не будет оптимизировать простое создание, так как сейчас внутри происходят вызовы функций, находящихся в других единицах трансляции, поэтому тест получится объективными.
\begin{lstlisting}[caption={Бенчмарк создания анонимных функций},label={lst:benchmark-create-simple}]
$n = (int)2e8;
$res = 0;
for ($i = 0; $i < $n; $i++) {
    $f = function($x) { return $x; };
    $res ^= $i;
}
var_dump($res);
\end{lstlisting}

Проделав замер времени работы, получаем следующую картину, показанную на рисунке \ref{fig:benchmark-create-simple}.
Hack представил себя медленнее KPHP всего в 1.3 раза, но эти результаты получились после JIT-а, так например первые 10 запросов к серверу HHVM работали по 12 секунд для теста из листинга \ref{lst:benchmark-create-simple}.
\begin{figure}[H]
    \caption{Сравнение затраченного времени на создание лямбда-функций}
    \label{fig:benchmark-create-simple}
    \centering
    \includegraphics[width=\linewidth]{images/benchmark_create_simple}
\end{figure}

Сравним время которое уходит на вызов созданной лямбда-функции.
Код, который был запущен на всех трех языках представлен в листинге \ref{lst:benchmark-call-simple}.
\begin{lstlisting}[caption={Бенчмарк вызовов анонимных функций},label={lst:benchmark-call-simple}]
$n = (int)2e8;
$res = 0;
$f = function($x) { return $x; };
for ($i = 0; $i < $n; $i++) {
    $res ^= f($i);
}
var_dump($res);
\end{lstlisting}

Результат замеров дал следующие результаты представленные на рисунке \ref{fig:benchmark-call-simple}.
мы видимо как вызов лямбда-функции успешно был встроен в место использования, что привело к нулевым накладным расходам.
\begin{figure}[H]
    \caption{Сравнение затраченного времени на вызов лямбда-функций}
    \label{fig:benchmark-call-simple}
    \centering
    \includegraphics[width=\linewidth]{images/benchmark_call_simple}
\end{figure}

Теперь давайте взглянем на время работы копирования анонимных функций в параметры функций.
Создадим простую лямбда-функцию и будем в цикле ее передавать в другую функцию.
Тест представлен в листинге \ref{lst:benchmark-copy-simple}.
\begin{lstlisting}[caption={Бенчмарк копирования анонимных функций},label={lst:benchmark-copy-simple}]
function foo(callable $f) {}

$n = (int)2e8;
$res = 0;
$f = function($x) { return $x; };
for ($i = 0; $i < $n; $i++) {
    foo($f);
}
var_dump($res);
\end{lstlisting}

На рисунке \ref{fig:benchmark-copy-simple} отчетливо видно, как ссылочная семантика и реализация именно через классы хорошо работает.
У нас получилось дешевым, достаточно скопировать один указатель и увеличить счетчик ссылок, без какой-либо дополнительной мета-информации.
\begin{figure}[H]
    \caption{Сравнение затраченного времени на копирование лямбда-функций}
    \label{fig:benchmark-copy-simple}
    \centering
    \includegraphics[width=\linewidth]{images/benchmark_copy_simple}
\end{figure}

Также интересно посмотреть на время затраченное при использовании лямбда-функций, которые захватывают переменные из внешнего окружения.
Приведем один общий тест, который сравнивает, сколько времени работает создание и вызов лямбда-функции без захвата переменных и с захватом.
Тест, который запускался на разных языках представлен в листинге \ref{lst:benchmark-create_use_call-simple}, второй запуск был с закомментированной строчкой, которая создают лямбда функции и захватывает переменную.
\begin{lstlisting}[caption={Бенчмарк создания и вызова анонимных функций с захватом},label={lst:benchmark-create_use_call-simple}]
$n = (int)2e8;
$res = 0;
for ($i = 0; $i < $n; $i++) {
    $f = function($x) { return 20 + $x; };
    # $f = function($x) use ($i) { return $i + $x; };
    $res ^= $f($i);
}
var_dump($res);
\end{lstlisting}

На рисунке \ref{fig:benchmark-create_use_call-simple} представлен график сравнения запусков на по очереди заменив использование лямбда-функции с захватом и без.
Диаграмма показывает соотношение времени работы без использования захвата переменных и с использованием.
Можно заметить, что PHP ухудшает производительность почти в 1.5 раза, однако HHVM становится медленнее на 9\%.
В KPHP ничего не меняется, так как компилятор по прежнему справляется встроить лямбда-функцию в место использования и оптимизировать ее.
\begin{figure}[H]
    \caption{Сравнение затраченного времени на создание и вызов анонимных функций с захватом}
    \label{fig:benchmark-create_use_call-simple}
    \centering
    \includegraphics[width=\linewidth]{images/benchmark_create_use_call_simple}
\end{figure}

Давайте посмотрим на время создания интерфейсов.
Было проведено сравнение, в котором в цикле создавались обычные классы и классы которые реализуют интерфейсы.
Сравнение показало, что в PHP работает в 1.5 раза дольше, а Hack медленнее на целых 18\% процентов.
Также было выявлено, что в PHP и в HHVM создание классов с интерфейсами и без интерфейсов не отличается по времени,
однако в KPHP создание классов с интерфейсами работает на 7-8\% дольше.
Запустив программу вместе с \verb|perf|\cit{perf}, было выявлено, что это происходит из-за виртуальных вызовов функций для подсчета ссылок и освобождения памяти.
Так как в случае интерфейсов эти функции не могут быть девиртуализованны\cite{devirtualization}, то встраивание происходит не так глубоко и оптимизитатор работает хуже, что мы и видим при запуске тестов.

Также было проведено сравнение времени работы вызова виртуальных функций.
С помощью этого механизма будут реализован механизм сохранения разных лямбда-функций в одну переменную.
Результаты оказались такими, что сейчас в KPHP сделано совсем не оптимальным способом работа с интерфейсными методами, так как там при каждом вызове в худшем случае может происходить \verb|n| вызовов \verb|dynamic_cast|, где \verb|n| - это количество классов, реализовавших данный интерфейс.
Данное решение можно достаточно легко соптимизировать, заменив подряд идущие проверки на \verb|switch| по \verb|typeid|\cite{fast-dynamic-cast}, однако сейчас это не требуется.
Тесты показали, что сейчас вызов виртуального метода работает в два раза дольше чем у Hack и всего лишь на 18\% процентов быстрее PHP.
Но в при добавлении возможности сохранять лямбда-функции в одну переменную, конечно же данное решение будет ускорено в разы.


\section{Сравнения использованной памяти}
тут посмотрим кто сколько жрет памяти.

\section{Улучшение качества кода и уменьшение ошибок}
Расскажу историю про usort и друзей.
Про более хороший вывод типов.

\chapterconclusion
Здесь мы сравнили.
Убедились, что наше решение работает в разы лучше аналогов.
Также потребляет меньше памяти.
Находит баги и вообще все супер круто.